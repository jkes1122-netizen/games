<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>禁史召喚 - Summoner of Forbidden History</title>
    <style>
        :root { --p1-bg: #1a1a2e; --p1-accent: #e94560; --p2-bg: #16213e; --p2-accent: #0f3460; --text-color: #f1f1f1; }
        body { background: #000; color: var(--text-color); font-family: "Microsoft JhengHei", sans-serif; margin: 0; padding: 10px; display: flex; flex-direction: column; height: 100vh; }
        header { display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 3px solid #e94560; background: #1a1a2e; }
        .turn-badge { font-size: 1.5rem; background: #e94560; color: #fff; padding: 5px 25px; border-radius: 5px; font-weight: bold; box-shadow: 0 0 15px #e94560; }
        .battlefield { display: flex; flex: 1; gap: 15px; margin-top: 15px; overflow: hidden; }
        .side { flex: 1; padding: 15px; border-radius: 12px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); }
        #side-p1 { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); }
        #side-p2 { background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%); }
       .slot {
    background: rgba(0,0,0,0.4);
    border: 2px dashed #444;
    border-radius: 10px;
    /* 修改：將 min-height 從 140px 增加到 200px，確保 4 個技能有足夠空間 */
    min-height: 200px; 
    display: flex;
    flex-direction: column;
    /* 修改：改為從頂部對齊，避免內容垂直置中導致的排版錯亂 */
    justify-content: flex-start; 
    align-items: center;
    position: relative;
    transition: all 0.3s;
    padding: 10px 0; /* 增加上下內距 */
}
       .char-card {
    width: 100%;
    padding: 12px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    height: 100%; /* 讓卡片撐滿 slot */
}
        .char-name { font-weight: bold; font-size: 1.2em; text-shadow: 0 0 5px rgba(255,255,255,0.3); }
        
        /* 品質顏色 */
        .q-green { color: #2ecc71; }
        .q-blue { color: #3498db; }
        .q-purple { color: #9b59b6; }
        .q-orange { color: #e67e22; }
        .q-red { color: #e74c3c; }
        .q-gold { color: #f1c40f; }

        .status-tag { background: #ff9f43; color: #000; font-size: 0.75rem; padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: bold; border: 1px solid #fff; }
        .hp-container { width: 100%; background: #222; height: 12px; border-radius: 6px; margin: 8px 0; border: 1px solid #444; overflow: hidden; }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #ff4d4d, #2ecc71); width: 100%; transition: width 0.4s ease; }
       .skill-list {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 維持兩欄排列 */
    gap: 10px; /* 稍微增加間距 */
    margin-top: 12px;
    width: 100%;
}
        
        .skill-btn { background: #0f3460; color: #fff; border: 1px solid #16213e; padding: 6px; font-size: 0.85rem; cursor: pointer; border-radius: 4px; transition: 0.2s; text-align: left; }
        .skill-btn:hover:not(:disabled) { background: #e94560; border-color: #fff; }
        .skill-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        
        .cat-攻 { color: #ff4d4d; font-weight: bold; margin-right: 4px; }
        .cat-防 { color: #f1c40f; font-weight: bold; margin-right: 4px; }
        .cat-技 { color: #00d2ff; font-weight: bold; margin-right: 4px; }

        .slot.acted { opacity: 0.4; filter: contrast(0.8); }
        .slot.targetable { border: 2px solid #f1c40f; box-shadow: 0 0 20px #f1c40f; transform: scale(1.02); z-index: 10; cursor: crosshair; }
        .slot.dead { filter: grayscale(1) brightness(0.5); }
        .control-panel { height: 160px; display: flex; gap: 15px; margin-top: 15px; }
        .log-box { flex: 3; background: #000; border: 1px solid #e94560; padding: 12px; overflow-y: scroll; font-family: 'Courier New', monospace; color: #00ff00; font-size: 0.95rem; border-radius: 8px; }
        .btn-group { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .main-btn { flex: 2; background: #e94560; color: #fff; border: none; font-size: 1.2rem; font-weight: bold; cursor: pointer; border-radius: 8px; text-transform: uppercase; letter-spacing: 2px; }
        .reset-btn { flex: 1; background: #444; color: #ccc; border: 1px solid #666; font-size: 0.9rem; cursor: pointer; border-radius: 8px; }
        .reset-btn:hover { background: #ff4d4d; color: #fff; }
        .add-btn { background: #333; color: #fff; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 2rem; cursor: pointer; }
        .add-interface { width: 90%; display: none; flex-direction: column; gap: 8px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; }
        input { background: #000; color: #fff; border: 1px solid #444; padding: 5px; }
        .limit-badge {
            background: rgba(255, 255, 255, 0.05); border: 1px solid #666; 
            padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; animation: fadeIn 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<header>
    <div><h1 style="margin:0; letter-spacing: 3px;">禁史召喚</h1><small>FORBIDDEN HISTORY SUMMONER - 數位裁判系統</small></div>
    <div style="text-align: right">
        <div class="turn-badge">ROUND <span id="turn-count">1</span></div>
        <div id="dynamic-counters" style="margin-top: 8px; display: flex; flex-direction: column; align-items: flex-end; gap: 4px;"></div>
    </div>
</header>

<div class="battlefield">
    <div class="side" id="side-p1"><h3 style="margin:0; text-align:center; color:#00d2ff">我方 陣營</h3></div>
    <div class="side" id="side-p2"><h3 style="margin:0; text-align:center; color:#ff4d4d">敵方 陣營</h3></div>
</div>

<div class="control-panel">
    <div class="log-box" id="combat-log">> 禁忌之門已開啟，請召喚角色...</div>
    <div class="btn-group">
        <button class="main-btn" onclick="nextTurn()">結束回合<br>END ROUND</button>
        <button class="reset-btn" onclick="resetBattlefield()">清理對局 (重置戰場)</button>
    </div>
</div>

<datalist id="char-list-data"></datalist>

<script>
    // --- 遊戲規則定義 ---
    const ROLE_BASES = {
        "行刑者": { hp: 1000, atk: 30 },
        "守誓者": { hp: 3000, atk: 0 },
        "詭術師": { hp: 2000, atk: 10 }
    };

    const QUALITY_BONUS = {
        "綠色": { hp: 0, atk: 0, color: "q-green" },
        "藍色": { hp: 500, atk: 10, color: "q-blue" },
        "紫色": { hp: 1000, atk: 20, color: "q-purple" },
        "橙色": { hp: 2000, atk: 40, color: "q-orange" },
        "紅色": { hp: 5000, atk: 50, color: "q-red" },
        "金色": { hp: 10000, atk: 100, color: "q-gold" }
    };

    const characterDatabase = [
        {
            id: "ranger", name: "英國遊騎兵", role: "行刑者", quality: "藍色", tag: "ranger",
            skills: [
                { name: "精準射擊", damage: 100, type: "true_dmg", cat: "攻" },
                { name: "槍林彈雨", damage: 150, type: "ranger_link", cat: "攻" },
                { name: "疾風步伐", damage: 0, type: "self_buff", effect: "dodge", duration: 2, cat: "技" }
            ]
        },
        {
            id: "guan_yu", name: "關羽", role: "行刑者", quality: "紫色", tag: "hero",
            skills: [
                { name: "青龍偃月", damage: 200, type: "physical", cat: "攻" },
                { name: "龍魂斬", damage: 150, type: "physical", cat: "攻" },
                { name: "武聖威嚴", damage: 0, type: "enemy_debuff", effect: "weak", duration: 3, cat: "技" }
            ]
        },
        {
            id: "wei_yan", name: "魏延", role: "行刑者", quality: "橙色", tag: "hero",
            skills: [
                { name: "斬月閃", damage: 150, type: "physical", cat: "攻" },
                { name: "反骨刃", damage: 180, type: "physical", cat: "攻" },
                { name: "狂戰", damage: 0, type: "self_buff", effect: "berserk", duration: 2, cat: "技" }
            ]
        },
        {
            id: "hj_shield", name: "黃巾刀盾兵", role: "守誓者", quality: "綠色", tag: "mob",
            skills: [
                { name: "鐵壁", damage: 0, type: "self_buff", effect: "dodge", duration: 1, cat: "防" },
                { name: "嘲諷", damage: 0, type: "self_buff", effect: "taunt", duration: 1, cat: "防" },
                { name: "誓約之力", damage: 0, type: "self_buff", effect: "shield", duration: 2, cat: "技" }
            ]
        },
        {
            id: "hj_axe", name: "黃巾斧手", role: "行刑者", quality: "綠色", tag: "mob",
            skills: [
                { name: "重劈", damage: 80, type: "physical", cat: "攻" },
                { name: "橫掃", damage: 60, type: "physical", cat: "攻" },
                { name: "怒吼", damage: 0, type: "self_buff", effect: "atk_up", duration: 2, cat: "技" }
            ]
        },
        {
            id: "hj_peasant", name: "黃巾農兵", role: "詭術師", quality: "綠色", tag: "mob",
            skills: [
                { name: "草鐮割", damage: 40, type: "physical", cat: "攻" },
                { name: "泥沼", damage: 0, type: "self_buff", effect: "dodge", duration: 1, cat: "防" },
                { name: "符水", damage: 0, type: "self_buff", effect: "heal", duration: 1, cat: "技" }
            ]
        }
    ];

    let battlefield = { p1: [null, null, null, null, null], p2: [null, null, null, null, null] };
    let sideResources = { p1: { rangerLinkLimit: 2 }, p2: { rangerLinkLimit: 2 } }; 
    let currentTurn = 1;
    let pendingAction = null;

    window.onload = function() { initDatalist(); renderBattlefield(); };

    function initDatalist() {
        const list = document.getElementById('char-list-data');
        characterDatabase.forEach(char => {
            const option = document.createElement('option');
            option.value = char.name;
            list.appendChild(option);
        });
    }

    // --- 核心微調：動態渲染計數器 ---
    function renderBattlefield() {
        renderSide('p1', document.getElementById('side-p1'));
        renderSide('p2', document.getElementById('side-p2'));
        const counterContainer = document.getElementById('dynamic-counters');
        counterContainer.innerHTML = ''; 

        ['p1', 'p2'].forEach(side => {
            const sideName = side === 'p1' ? '我方' : '敵方';
            const sideColor = side === 'p1' ? '#00d2ff' : '#ff4d4d';
            
            // 基礎架構設計：未來這裡可以加入多種技能的檢查
            // 1. 檢查英國遊騎兵
            const hasActiveRanger = battlefield[side].some(u => u && u.tag === "ranger" && u.hp > 0);
            if (hasActiveRanger) {
                createLimitBadge(counterContainer, `${sideName} 槍林彈雨`, sideResources[side].rangerLinkLimit, 2, sideColor);
            }

            // 未來範例：如果你加了「魔導師」角色且有魔力限制
            // if (battlefield[side].some(u => u && u.tag === "mage" && u.hp > 0)) {
            //     createLimitBadge(counterContainer, `${sideName} 秘法值`, sideResources[side].mana, 100, sideColor);
            // }
        });
    }

    // 通用的計數器生成函式，方便以後擴充
    function createLimitBadge(container, label, current, max, color) {
        const badge = document.createElement('div');
        badge.className = 'limit-badge';
        badge.style.borderColor = color;
        badge.style.color = color;
        badge.innerText = `${label}：${current} / ${max}`;
        container.appendChild(badge);
    }

    function renderSide(sideKey, container) {
        const title = container.querySelector('h3');
        container.innerHTML = ''; container.appendChild(title);
        battlefield[sideKey].forEach((char, index) => {
            const slotDiv = document.createElement('div');
            slotDiv.className = `slot`;
            slotDiv.dataset.side = sideKey; slotDiv.dataset.index = index;
            if (!char) {
                slotDiv.innerHTML = `<button class="add-btn" onclick="toggleAddMenu('${sideKey}', ${index})">+</button><div class="add-interface" id="add-menu-${sideKey}-${index}"><input list="char-list-data" id="input-${sideKey}-${index}"><button onclick="addCharacter('${sideKey}', ${index})">召喚</button></div>`;
            } else {
                if (char.hp <= 0) slotDiv.classList.add('dead');
                if (char.acted) slotDiv.classList.add('acted');
                const hpPercent = (char.hp / char.maxHp) * 100;
                const qClass = QUALITY_BONUS[char.quality]?.color || "q-green";

                let statusHtml = char.statuses.map(s => {
                    const label = s.id === 'weak' ? '虛弱' : s.id === 'dodge' ? '閃避' : s.id;
                    return `<span class="status-tag">${label}(${s.duration})</span>`;
                }).join('');

                let normalAtkBtn = "";
                if (char.role !== "守誓者") {
                    const isDisabled = char.acted ? 'disabled' : '';
                    normalAtkBtn = `<button class="skill-btn" ${isDisabled} onclick="selectSkill('${sideKey}', ${index}, -1)"><span class="cat-攻">攻</span>普攻 (${char.atk})</button>`;
                }

                let skillsHtml = char.skills.map((s, sIdx) => {
                    const isRangerLimit = (s.type === 'ranger_link' && sideResources[sideKey].rangerLinkLimit <= 0);
                    const isDisabled = (char.acted || isRangerLimit) ? 'disabled' : '';
                    const catClass = `cat-${s.cat || '技'}`;
                    return `<button class="skill-btn" ${isDisabled} onclick="selectSkill('${sideKey}', ${index}, ${sIdx})"><span class="${catClass}">${s.cat || '技'}</span>${s.name}</button>`;
                }).join('');

                slotDiv.innerHTML = `<div class="char-card"><div class="char-header">
                    <span class="char-name ${qClass}">${char.name}</span>${statusHtml}
                    <div style="font-size:0.7rem; opacity:0.6">${char.role} | ${char.quality} | ATK: ${char.atk}</div>
                    <small onclick="removeChar('${sideKey}', ${index})" style="cursor:pointer; opacity:0.3; float:right">移除</small>
                    </div><div class="hp-container"><div class="hp-fill" style="width: ${hpPercent}%"></div></div><small>HP: ${char.hp}/${char.maxHp}</small>
                    <div class="skill-list">${normalAtkBtn}${skillsHtml}</div></div>`;
                
                slotDiv.onclick = function(e) { 
                    if(e.target.tagName !== 'BUTTON' && pendingAction && slotDiv.classList.contains('targetable')) {
                        resolveAttack(sideKey, index); 
                    }
                }
            }
            container.appendChild(slotDiv);
        });
    }

    function toggleAddMenu(side, index) { document.getElementById(`add-menu-${side}-${index}`).style.display = 'flex'; }
    
    function addCharacter(side, index) {
        const inputVal = document.getElementById(`input-${side}-${index}`).value;
        const template = characterDatabase.find(c => c.name === inputVal);
        if (!template) return;
        
        let newChar = JSON.parse(JSON.stringify(template));
        const roleBase = ROLE_BASES[newChar.role] || { hp: 1000, atk: 10 };
        const qualityAdd = QUALITY_BONUS[newChar.quality] || { hp: 0, atk: 0 };
        
        newChar.maxHp = roleBase.hp + qualityAdd.hp;
        newChar.hp = newChar.maxHp;
        newChar.atk = roleBase.atk + qualityAdd.atk;
        newChar.acted = false; 
        newChar.statuses = [];
        
        battlefield[side][index] = newChar;
        renderBattlefield();
    }

    function removeChar(side, index) { battlefield[side][index] = null; renderBattlefield(); }

    function selectSkill(side, index, skillIndex) {
        const actor = battlefield[side][index];
        if (!actor || actor.hp <= 0 || actor.acted) return;
        
        let skill;
        if (skillIndex === -1) {
            skill = { name: "普攻", damage: actor.atk, type: "normal_atk", cat: "攻" };
        } else {
            skill = actor.skills[skillIndex];
        }

        if (skill.type === "ranger_link" && sideResources[side].rangerLinkLimit <= 0) { 
            addLog(`❌ ${side === 'p1' ? '我方' : '敵方'}聯動能量已耗盡。`); return; 
        }

        if (skill.type === 'self_buff') {
            actor.statuses.push({ id: skill.effect, duration: skill.duration || 1 }); 
            actor.acted = true;
            addLog(`> ${actor.name} 使用了 【${skill.name}】！`); 
            renderBattlefield(); return;
        }

        pendingAction = { side, index, skill, actorName: actor.name };
        addLog(`> ${actor.name} 準備施放 ${skill.name}，請選擇目標...`);
        highlightTargets(side === 'p1' ? 'p2' : 'p1');
    }

    function highlightTargets(targetSide) {
        document.querySelectorAll(`.slot[data-side="${targetSide}"]`).forEach(el => {
            const char = battlefield[targetSide][el.dataset.index];
            if (char && char.hp > 0) el.classList.add('targetable');
        });
    }

    function resolveAttack(targetSide, targetIndex) {
        if (!pendingAction) return;
        const actor = battlefield[pendingAction.side][pendingAction.index];
        const target = battlefield[targetSide][targetIndex];
        const skill = pendingAction.skill;

        let baseDamage = 0;
        if (skill.type === "ranger_link") {
            const side = pendingAction.side;
            const rangerCount = battlefield[side].filter(u => u && u.tag === "ranger" && u.hp > 0).length;
            baseDamage = 150 * rangerCount; 
            sideResources[side].rangerLinkLimit--; 
        } else if (skill.type === "normal_atk") {
            baseDamage = actor.atk;
        } else {
            baseDamage = skill.damage;
        }

        let modifiedDamage = baseDamage;
        if (actor.statuses.some(s => s.id === "weak")) { 
            modifiedDamage = Math.floor(modifiedDamage * 0.5); 
        }

        let finalDamage = modifiedDamage;
        if (skill.type === "enemy_debuff") { 
            target.statuses.push({ id: skill.effect, duration: skill.duration || 1 }); 
        }

        if (skill.type !== "true_dmg" && target.statuses.some(s => s.id === "dodge")) {
            finalDamage = 0; 
            target.statuses = target.statuses.filter(s => s.id !== "dodge");
            addLog(`> ${target.name} 透過閃避躲開了攻擊！`);
        }

        target.hp = Math.max(0, target.hp - finalDamage);
        actor.acted = true; 
        
        if(finalDamage > 0 || (finalDamage === 0 && skill.damage > 0)) {
            addLog(`> ${actor.name} 對 ${target.name} 造成 ${finalDamage} 點傷害。`);
        }
        if(target.hp <= 0) {
            addLog(`> [魂滅] ${target.name} 已退出戰場。`);
        }

        pendingAction = null;
        document.querySelectorAll('.slot').forEach(el => el.classList.remove('targetable'));
        renderBattlefield(); // 這裡會自動處理計數器的動態消失（如果角色陣亡）
    }

  function nextTurn() {
        currentTurn++;
        document.getElementById('turn-count').innerText = currentTurn;
        
        // --- 規則修改：移除以下兩行，使技能次數不在回合結束時重置 ---
        // sideResources.p1.rangerLinkLimit = 2;
        // sideResources.p2.rangerLinkLimit = 2;
        
        ['p1', 'p2'].forEach(side => { 
            battlefield[side].forEach(char => { 
                if (char) {
                    char.acted = false; 
                    char.statuses.forEach(s => s.duration--);
                    const expired = char.statuses.filter(s => s.duration <= 0);
                    expired.forEach(s => {
                        const label = s.id === 'weak' ? '虛弱' : s.id === 'dodge' ? '閃避' : s.id;
                        addLog(`> ${char.name} 的狀態 [${label}] 已結束。`);
                    });
                    char.statuses = char.statuses.filter(s => s.duration > 0);
                }
            }); 
        });
        
        addLog(`--- 第 ${currentTurn} 回合 (雙方行動重置，限定技能次數不恢復) ---`);
        renderBattlefield();
    }
        
        addLog(`--- 第 ${currentTurn} 回合 (雙方行動重置) ---`);
        renderBattlefield();
    }

    function resetBattlefield() {
        if (confirm("是否確定重啟《禁史召喚》對局？")) {
            battlefield = { p1: [null, null, null, null, null], p2: [null, null, null, null, null] };
            sideResources = { p1: { rangerLinkLimit: 2 }, p2: { rangerLinkLimit: 2 } }; 
            currentTurn = 1; 
            document.getElementById('turn-count').innerText = currentTurn;
            document.getElementById('combat-log').innerHTML = "> 戰場已清空。";
            renderBattlefield();
        }
    }

    function addLog(msg) {
        const log = document.getElementById('combat-log');
        log.innerHTML = msg + "<br>" + log.innerHTML;
    }
</script>
</body>
</html>
