<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>禁史召喚 - Summoner of Forbidden History</title>
    <style>
        :root { --p1-bg: #1a1a2e; --p1-accent: #e94560; --p2-bg: #16213e; --p2-accent: #0f3460; --text-color: #f1f1f1; }
        body { background: #000; color: var(--text-color); font-family: "Microsoft JhengHei", sans-serif; margin: 0; padding: 10px; display: flex; flex-direction: column; height: 100vh; }
        header { display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 3px solid #e94560; background: #1a1a2e; }
        .turn-badge { font-size: 1.5rem; background: #e94560; color: #fff; padding: 5px 25px; border-radius: 5px; font-weight: bold; box-shadow: 0 0 15px #e94560; }
        .battlefield { display: flex; flex: 1; gap: 15px; margin-top: 15px; overflow: hidden; }
        .side { flex: 1; padding: 15px; border-radius: 12px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; border: 1px solid rgba(255,255,255,0.1); }
        #side-p1 { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); }
        #side-p2 { background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%); }
        .slot { background: rgba(0,0,0,0.4); border: 2px dashed #444; border-radius: 10px; min-height: 140px; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; transition: all 0.3s; }
        .char-card { width: 100%; padding: 12px; box-sizing: border-box; }
        .char-name { font-weight: bold; font-size: 1.2em; color: #00d2ff; text-shadow: 0 0 5px #00d2ff; }
        .status-tag { background: #ff9f43; color: #000; font-size: 0.75rem; padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: bold; }
        .hp-container { width: 100%; background: #222; height: 12px; border-radius: 6px; margin: 8px 0; border: 1px solid #444; overflow: hidden; }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #ff4d4d, #2ecc71); width: 100%; transition: width 0.4s ease; }
        .skill-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
        .skill-btn { background: #0f3460; color: #fff; border: 1px solid #16213e; padding: 6px; font-size: 0.85rem; cursor: pointer; border-radius: 4px; transition: 0.2s; }
        .skill-btn:hover:not(:disabled) { background: #e94560; border-color: #fff; }
        .skill-btn:disabled { opacity: 0.2; cursor: not-allowed; }
        .slot.acted { opacity: 0.4; filter: contrast(0.8); pointer-events: none; }
        .slot.targetable { border: 2px solid #f1c40f; box-shadow: 0 0 20px #f1c40f; transform: scale(1.02); z-index: 10; cursor: crosshair; }
        .slot.dead { filter: grayscale(1) brightness(0.5); }
        .control-panel { height: 160px; display: flex; gap: 15px; margin-top: 15px; }
        .log-box { flex: 3; background: #000; border: 1px solid #e94560; padding: 12px; overflow-y: scroll; font-family: 'Courier New', monospace; color: #00ff00; font-size: 0.95rem; border-radius: 8px; }
        .btn-group { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .main-btn { flex: 2; background: #e94560; color: #fff; border: none; font-size: 1.2rem; font-weight: bold; cursor: pointer; border-radius: 8px; text-transform: uppercase; letter-spacing: 2px; }
        .reset-btn { flex: 1; background: #444; color: #ccc; border: 1px solid #666; font-size: 0.9rem; cursor: pointer; border-radius: 8px; }
        .reset-btn:hover { background: #ff4d4d; color: #fff; }
        .add-btn { background: #333; color: #fff; border: none; width: 50px; height: 50px; border-radius: 50%; font-size: 2rem; cursor: pointer; }
        .add-interface { width: 90%; display: none; flex-direction: column; gap: 8px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; }
        input { background: #000; color: #fff; border: 1px solid #444; padding: 5px; }
        .limit-badge {
    background: rgba(0, 210, 255, 0.15);
    border: 1px solid #00d2ff;
    color: #00d2ff;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.8rem;
    animation: fadeIn 0.5s;
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<header>
    <div><h1 style="margin:0; letter-spacing: 3px;">禁史召喚</h1><small>FORBIDDEN HISTORY SUMMONER - 數位裁判系統</small></div>
    <div style="text-align: right">
        <div class="turn-badge">ROUND <span id="turn-count">1</span></div>
       <div style="text-align: right">
    <div class="turn-badge">ROUND <span id="turn-count">1</span></div>
    <div id="dynamic-counters" style="margin-top: 8px; display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
    </div>
</div>
</header>

<div class="battlefield">
    <div class="side" id="side-p1"><h3 style="margin:0; text-align:center; color:#00d2ff">召喚師 陣營</h3></div>
    <div class="side" id="side-p2"><h3 style="margin:0; text-align:center; color:#ff4d4d">禁史 陣營</h3></div>
</div>

<div class="control-panel">
    <div class="log-box" id="combat-log">> 禁忌之門已開啟，請召喚角色...</div>
    <div class="btn-group">
        <button class="main-btn" onclick="nextTurn()">結束回合<br>END ROUND</button>
        <button class="reset-btn" onclick="resetBattlefield()">清理對局 (重置戰場)</button>
    </div>
</div>

<datalist id="char-list-data"></datalist>

<script>
    // 1. 《禁史召喚》大數據庫
    const characterDatabase = [
        {
            id: "ranger", name: "英國遊騎兵", hp: 500, tag: "ranger",
            skills: [
                { name: "精準射擊", damage: 100, type: "true_dmg" },
                { name: "槍林彈雨", damage: 150, type: "ranger_link" },
                { name: "疾風步伐", damage: 0, type: "self_buff", effect: "dodge" }
            ]
        },
        {
            id: "guan_yu", name: "關羽", hp: 1200, tag: "hero",
            skills: [
                { name: "青龍偃月", damage: 200, type: "physical" },
                { name: "武聖威嚴", damage: 0, type: "enemy_debuff", effect: "weak" }
            ]
        },
        {
            id: "wei_yan", name: "魏延", hp: 1000, tag: "hero",
            skills: [{ name: "斬月閃", damage: 150, type: "physical" }]
        },
        {
            id: "soldier", name: "一般小兵", hp: 200, tag: "mob",
            skills: [{ name: "突刺", damage: 50, type: "physical" }]
        }
    ];

    let battlefield = { p1: [null, null, null, null, null], p2: [null, null, null, null, null] };
    let currentTurn = 1;
    let pendingAction = null;
    let globalRangerLinkLimit = 2; 

    window.onload = function() { initDatalist(); renderBattlefield(); };

    function initDatalist() {
        const list = document.getElementById('char-list-data');
        characterDatabase.forEach(char => {
            const option = document.createElement('option');
            option.value = char.name;
            list.appendChild(option);
        });
    }

 function renderBattlefield() {
    renderSide('p1', document.getElementById('side-p1'));
    renderSide('p2', document.getElementById('side-p2'));
    
    // --- 動態計數器邏輯 ---
    const counterContainer = document.getElementById('dynamic-counters');
    counterContainer.innerHTML = ''; // 先清空

    // 檢查全戰場是否有人擁有「ranger」標籤
    const allUnits = [...battlefield.p1, ...battlefield.p2].filter(u => u !== null);
    const hasRanger = allUnits.some(u => u.tag === "ranger");

    // 如果場上有遊騎兵，才顯示計數器
    if (hasRanger) {
        const badge = document.createElement('div');
        badge.className = 'limit-badge';
        badge.innerText = `槍林彈雨限制：${globalRangerLinkLimit} / 2`;
        counterContainer.appendChild(badge);
    }

    function renderSide(sideKey, container) {
        const title = container.querySelector('h3');
        container.innerHTML = ''; container.appendChild(title);
        battlefield[sideKey].forEach((char, index) => {
            const slotDiv = document.createElement('div');
            slotDiv.className = `slot`;
            slotDiv.dataset.side = sideKey; slotDiv.dataset.index = index;
            if (!char) {
                slotDiv.innerHTML = `<button class="add-btn" onclick="toggleAddMenu('${sideKey}', ${index})">+</button><div class="add-interface" id="add-menu-${sideKey}-${index}"><input list="char-list-data" id="input-${sideKey}-${index}"><button onclick="addCharacter('${sideKey}', ${index})">召喚</button></div>`;
            } else {
                if (char.hp <= 0) slotDiv.classList.add('dead');
                if (char.acted) slotDiv.classList.add('acted');
                const hpPercent = (char.hp / char.maxHp) * 100;
                let statusHtml = char.statuses.map(s => `<span class="status-tag">${s === 'weak' ? '虛弱' : s === 'dodge' ? '閃避' : s}</span>`).join('');
                let skillsHtml = char.skills.map((s, sIdx) => {
                    const isDisabled = (s.type === 'ranger_link' && globalRangerLinkLimit <= 0) ? 'disabled' : '';
                    return `<button class="skill-btn" ${isDisabled} onclick="selectSkill('${sideKey}', ${index}, ${sIdx})">${s.name}</button>`;
                }).join('');

                slotDiv.innerHTML = `<div class="char-card"><div class="char-header"><span class="char-name">${char.name}${statusHtml}</span><small onclick="removeChar('${sideKey}', ${index})" style="cursor:pointer; opacity:0.3">移除</small></div><div class="hp-container"><div class="hp-fill" style="width: ${hpPercent}%"></div></div><small>生命值: ${char.hp} / ${char.maxHp}</small><div class="skill-list">${skillsHtml}</div></div>`;
                slotDiv.onclick = function(e) { if(e.target.tagName !== 'BUTTON' && pendingAction && slotDiv.classList.contains('targetable')) resolveAttack(sideKey, index); }
            }
            container.appendChild(slotDiv);
        });
    }

    function toggleAddMenu(side, index) { document.getElementById(`add-menu-${side}-${index}`).style.display = 'flex'; }
    function addCharacter(side, index) {
        const inputVal = document.getElementById(`input-${side}-${index}`).value;
        const template = characterDatabase.find(c => c.name === inputVal);
        if (!template) return;
        battlefield[side][index] = JSON.parse(JSON.stringify(template));
        battlefield[side][index].maxHp = template.hp; battlefield[side][index].acted = false; battlefield[side][index].statuses = [];
        renderBattlefield();
    }
    function removeChar(side, index) { battlefield[side][index] = null; renderBattlefield(); }

    function selectSkill(side, index, skillIndex) {
        const actor = battlefield[side][index];
        const skill = actor.skills[skillIndex];
        if (actor.hp <= 0 || actor.acted) return;
        if (skill.type === "ranger_link" && globalRangerLinkLimit <= 0) { addLog(`❌ 聯動能量已耗盡。`); return; }

        if (skill.type === 'self_buff') {
            actor.statuses.push(skill.effect); actor.acted = true;
            addLog(`> ${actor.name} 使用了 【${skill.name}】！`); renderBattlefield(); return;
        }

        pendingAction = { side, index, skill, actorName: actor.name };
        addLog(`> ${actor.name} 準備施放 ${skill.name}，請選擇目標...`);
        highlightTargets(side === 'p1' ? 'p2' : 'p1');
    }

    function highlightTargets(targetSide) {
        document.querySelectorAll(`.slot[data-side="${targetSide}"]`).forEach(el => {
            const char = battlefield[targetSide][el.dataset.index];
            if (char && char.hp > 0) el.classList.add('targetable');
        });
    }

    function resolveAttack(targetSide, targetIndex) {
        if (!pendingAction) return;
        const actor = battlefield[pendingAction.side][pendingAction.index];
        const target = battlefield[targetSide][targetIndex];
        const skill = pendingAction.skill;
        let finalDamage = skill.damage;

        if (actor.statuses.includes("weak")) { finalDamage = Math.floor(finalDamage * 0.5); actor.statuses = actor.statuses.filter(s => s !== "weak"); }
        if (skill.type === "enemy_debuff") { target.statuses.push(skill.effect); }
        if (skill.type === "ranger_link") {
            const rangerCount = battlefield[pendingAction.side].filter(u => u && u.tag === "ranger" && u.hp > 0).length;
            finalDamage = 150 * rangerCount; globalRangerLinkLimit--;
        }
        if (skill.type !== "true_dmg" && target.statuses.includes("dodge")) {
            finalDamage = 0; target.statuses = target.statuses.filter(s => s !== "dodge");
            addLog(`> ${target.name} 透過閃避躲開了攻擊！`);
        }

        target.hp = Math.max(0, target.hp - finalDamage);
        actor.acted = true;
        if(finalDamage > 0) addLog(`> ${actor.name} 對 ${target.name} 造成 ${finalDamage} 點傷害。`);
        if(target.hp <= 0) addLog(`> [魂滅] ${target.name} 已退出戰場。`);

        pendingAction = null;
        document.querySelectorAll('.slot').forEach(el => el.classList.remove('targetable'));
        renderBattlefield();
    }

    function nextTurn() {
        currentTurn++;
        document.getElementById('turn-count').innerText = currentTurn;
        ['p1', 'p2'].forEach(side => { battlefield[side].forEach(char => { if (char) char.acted = false; }); });
        addLog(`--- 第 ${currentTurn} 回合 (雙方行動重置) ---`);
        renderBattlefield();
    }

    function resetBattlefield() {
        if (confirm("是否確定清空戰場，重啟《禁史召喚》對局？")) {
            battlefield = { p1: [null, null, null, null, null], p2: [null, null, null, null, null] };
            currentTurn = 1; globalRangerLinkLimit = 2;
            document.getElementById('turn-count').innerText = currentTurn;
            document.getElementById('combat-log').innerHTML = "> 戰場已清空。請重新召喚角色。";
            renderBattlefield();
        }
    }

    function addLog(msg) {
        const log = document.getElementById('combat-log');
        log.innerHTML = msg + "<br>" + log.innerHTML;
    }
</script>
</body>
</html>
